<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8">
<title>AR Hình học 3D – Dạy học</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<style>
body{margin:0;overflow:hidden;font-family:Arial}
#ui{
 position:fixed;top:10px;left:10px;
 background:rgba(255,255,255,0.95);
 padding:10px;border-radius:10px;z-index:10;
 max-width:180px
}
select,button{width:100%;margin-top:6px;padding:6px}
#info{
 margin-top:6px;
 font-size:13px;
 color:#333;
}
</style>
</head>

<body>
<div id="ui">
<select id="shape">
 <option value="cube">Lập phương</option>
 <option value="triPrism">Lăng trụ tam giác</option>
 <option value="pyramid">Chóp tứ giác</option>
</select>
<button id="edgesBtn">Ẩn / hiện cạnh</button>
<button id="vertexBtn">Ẩn / hiện đỉnh</button>
<button id="rotateBtn">Bật / tắt xoay</button>
<button id="netBtn">Trải / gập Net</button>
<div id="info">Chạm 2 đỉnh để đo cạnh</div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/webxr/ARButton.js";

let scene,camera,renderer;
let model,edges,vertices=[],labels=[];
let autoRotate=false;
let selected=[]; // đo cạnh
let netOpen=false;

init();
animate();

function init(){
 scene=new THREE.Scene();
 camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.01,20);

 renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
 renderer.setSize(innerWidth,innerHeight);
 renderer.xr.enabled=true;
 document.body.appendChild(renderer.domElement);
 document.body.appendChild(ARButton.createButton(renderer));

 scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1.2));

 createShape();

 shape.onchange=createShape;
 edgesBtn.onclick=()=>edges.visible=!edges.visible;
 vertexBtn.onclick=()=>vertices.forEach(v=>v.visible=!v.visible);
 rotateBtn.onclick=()=>autoRotate=!autoRotate;
 netBtn.onclick=toggleNet;

 window.addEventListener("resize",resize);
 renderer.domElement.addEventListener("click",onTap);
}

function createShape(){
 if(model) scene.remove(model);
 vertices=[]; labels=[]; selected=[]; netOpen=false;

 let g;
 if(shape.value==="cube") g=new THREE.BoxGeometry(0.15,0.15,0.15);
 if(shape.value==="triPrism") g=new THREE.CylinderGeometry(0.08,0.08,0.18,3);
 if(shape.value==="pyramid") g=new THREE.ConeGeometry(0.1,0.18,4);

 g.clearGroups();
 const f=g.index.count/3;
 for(let i=0;i<f;i++) g.addGroup(i*3,3,i);

 const mats=[];
 for(let i=0;i<f;i++)
  mats.push(new THREE.MeshStandardMaterial({
   color:new THREE.Color().setHSL(i/f,0.85,0.6)
  }));

 model=new THREE.Mesh(g,mats);
 model.position.set(0,0,-0.6);
 scene.add(model);

 edges=new THREE.LineSegments(
  new THREE.EdgesGeometry(g),
  new THREE.LineBasicMaterial({color:0x000000})
 );
 model.add(edges);

 createVerticesAndLabels(g);
}

function createVerticesAndLabels(g){
 const pos=g.attributes.position;
 const used={};
 const names=["A","B","C","D","E","F","G","H"];
 let idx=0;

 for(let i=0;i<pos.count;i++){
  const key=`${pos.getX(i).toFixed(2)}_${pos.getY(i).toFixed(2)}_${pos.getZ(i).toFixed(2)}`;
  if(used[key]) continue;
  used[key]=true;

  const v=new THREE.Mesh(
   new THREE.SphereGeometry(0.01,16,16),
   new THREE.MeshBasicMaterial({color:0xff0000})
  );
  v.position.set(pos.getX(i),pos.getY(i),pos.getZ(i));
  model.add(v);
  vertices.push(v);

  if(idx<names.length){
   const label=makeText(names[idx++]);
   label.position.copy(v.position).add(new THREE.Vector3(0,0.015,0));
   model.add(label);
   labels.push(label);
  }
 }
}

function makeText(t){
 const c=document.createElement("canvas");
 c.width=128;c.height=64;
 const ctx=c.getContext("2d");
 ctx.fillStyle="white";
 ctx.fillRect(0,0,128,64);
 ctx.fillStyle="black";
 ctx.font="32px Arial";
 ctx.textAlign="center";
 ctx.textBaseline="middle";
 ctx.fillText(t,64,32);
 const tex=new THREE.CanvasTexture(c);
 return new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
}

function onTap(e){
 const mouse=new THREE.Vector2(
  (e.clientX/innerWidth)*2-1,
  -(e.clientY/innerHeight)*2+1
 );
 const ray=new THREE.Raycaster();
 ray.setFromCamera(mouse,camera);
 const hits=ray.intersectObjects(vertices);
 if(hits.length){
  selected.push(hits[0].object);
  if(selected.length===2){
   const d=selected[0].position.distanceTo(selected[1].position);
   info.innerText="Độ dài cạnh ≈ "+(d*100).toFixed(1)+" cm";
   selected=[];
  }
 }
}

function toggleNet(){
 if(shape.value!=="cube") return;
 netOpen=!netOpen;
 model.children.forEach(o=>{
  if(o.isMesh){
   o.position.z=netOpen?Math.random()*0.1:0;
  }
 });
}

function animate(){
 renderer.setAnimationLoop(()=>{
  if(model && autoRotate) model.rotation.y+=0.01;
  renderer.render(scene,camera);
 });
}

function resize(){
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>
