<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8">
<title>AR Hình học không gian 3D</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
body { margin:0; overflow:hidden; font-family:Arial }
#ui {
  position:fixed; top:10px; left:10px;
  background:rgba(255,255,255,0.92);
  padding:10px; border-radius:10px;
  z-index:10;
}
button, select {
  width:100%; margin-top:6px; padding:6px;
}
</style>
</head>

<body>
<div id="ui">
  <select id="shape">
    <option value="cube">Lập phương</option>
    <option value="sphere">Hình cầu</option>
    <option value="cylinder">Hình trụ</option>
    <option value="cone">Hình nón</option>
    <option value="triPrism">Lăng trụ tam giác</option>
    <option value="pyramid">Chóp tứ giác</option>
  </select>
  <button id="edgesBtn">Ẩn / hiện cạnh</button>
  <button id="vertexBtn">Ẩn / hiện đỉnh</button>
  <button id="rotateBtn">Bật / tắt xoay</button>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/webxr/ARButton.js";

let scene, camera, renderer;
let reticle, hitSource=null;
let model=null, edges=null, vertices=null;
let autoRotate=false;

init();
animate();

function init(){
  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.01,20);

  renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.xr.enabled=true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(ARButton.createButton(renderer,{requiredFeatures:["hit-test"]}));

  scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1.3));

  reticle=new THREE.Mesh(
    new THREE.RingGeometry(0.06,0.08,32),
    new THREE.MeshBasicMaterial({color:0x00ff00})
  );
  reticle.rotation.x=-Math.PI/2;
  reticle.visible=false;
  scene.add(reticle);

  renderer.xr.addEventListener("sessionstart", async()=>{
    const session=renderer.xr.getSession();
    const viewer=await session.requestReferenceSpace("viewer");
    hitSource=await session.requestHitTestSource({space:viewer});
  });

  renderer.domElement.addEventListener("click",()=>{
    if(!reticle.visible) return;
    if(!model) createShape();
    model.position.copy(reticle.position);
  });

  setupUI();
  window.addEventListener("resize",resize);
}

function createShape(){
  if(model) scene.remove(model);

  const type=shape.value;
  let g;
  if(type==="cube") g=new THREE.BoxGeometry(0.15,0.15,0.15);
  if(type==="sphere") g=new THREE.SphereGeometry(0.1,32,32);
  if(type==="cylinder") g=new THREE.CylinderGeometry(0.08,0.08,0.18,32);
  if(type==="cone") g=new THREE.ConeGeometry(0.09,0.18,32);
  if(type==="triPrism") g=new THREE.CylinderGeometry(0.08,0.08,0.18,3);
  if(type==="pyramid") g=new THREE.ConeGeometry(0.1,0.18,4);

  g.clearGroups();
  const f=g.index.count/3;
  for(let i=0;i<f;i++) g.addGroup(i*3,3,i);

  const mats=[];
  for(let i=0;i<f;i++){
    mats.push(new THREE.MeshStandardMaterial({
      color:new THREE.Color().setHSL(i/f,0.85,0.6)
    }));
  }

  model=new THREE.Mesh(g,mats);
  scene.add(model);

  edges=new THREE.LineSegments(
    new THREE.EdgesGeometry(g),
    new THREE.LineBasicMaterial({color:0x000000})
  );
  model.add(edges);

  vertices=new THREE.Group();
  if(["cube","triPrism","pyramid"].includes(type)){
    const p=g.attributes.position;
    const used={};
    for(let i=0;i<p.count;i++){
      const k=`${p.getX(i).toFixed(2)}_${p.getY(i).toFixed(2)}_${p.getZ(i).toFixed(2)}`;
      if(used[k]) continue;
      used[k]=true;
      const s=new THREE.Sprite(new THREE.SpriteMaterial({color:0xff0000}));
      s.position.set(p.getX(i),p.getY(i),p.getZ(i));
      s.scale.set(0.025,0.025,0.025);
      vertices.add(s);
    }
  }
  model.add(vertices);
}

function setupUI(){
  edgesBtn.onclick=()=>edges.visible=!edges.visible;
  vertexBtn.onclick=()=>vertices.visible=!vertices.visible;
  rotateBtn.onclick=()=>autoRotate=!autoRotate;
}

function animate(){
  renderer.setAnimationLoop((t,frame)=>{
    if(frame && hitSource){
      const ref=renderer.xr.getReferenceSpace();
      const hits=frame.getHitTestResults(hitSource);
      if(hits.length){
        reticle.visible=true;
        reticle.matrix.fromArray(hits[0].getPose(ref).transform.matrix);
        reticle.matrix.decompose(reticle.position,reticle.quaternion,reticle.scale);
      }
    }
    if(model && autoRotate) model.rotation.y+=0.01;
    renderer.render(scene,camera);
  });
}

function resize(){
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>
