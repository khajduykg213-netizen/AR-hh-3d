<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8">
<title>AR H√¨nh h·ªçc 3D ‚Äì ·ªîn ƒë·ªãnh</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<style>
body{margin:0;overflow:hidden;font-family:Arial}
#ui{
 position:fixed;top:10px;left:10px;
 background:rgba(255,255,255,0.95);
 padding:10px;border-radius:10px;z-index:10
}
select,button{width:100%;margin-top:6px;padding:6px}
</style>
</head>

<body>
<div id="ui">
<select id="shape">
 <option value="cube">L·∫≠p ph∆∞∆°ng</option>
 <option value="sphere">H√¨nh c·∫ßu</option>
 <option value="cylinder">H√¨nh tr·ª•</option>
 <option value="cone">H√¨nh n√≥n</option>
 <option value="triPrism">LƒÉng tr·ª• tam gi√°c</option>
 <option value="pyramid">Ch√≥p t·ª© gi√°c</option>
</select>
<button id="edgesBtn">·∫®n / hi·ªán c·∫°nh</button>
<button id="vertexBtn">·∫®n / hi·ªán ƒë·ªânh</button>
<button id="rotateBtn">B·∫≠t / t·∫Øt xoay</button>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/webxr/ARButton.js";

let scene,camera,renderer;
let model,edges,vertices;
let autoRotate=false;

init();
animate();

function init(){
 scene=new THREE.Scene();
 camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.01,20);

 renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
 renderer.setSize(innerWidth,innerHeight);
 renderer.xr.enabled=true;
 document.body.appendChild(renderer.domElement);
 document.body.appendChild(ARButton.createButton(renderer));

 scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1.2));

 createShape();

 shape.onchange=createShape;
 edgesBtn.onclick=()=>edges.visible=!edges.visible;
 vertexBtn.onclick=()=>vertices.visible=!vertices.visible;
 rotateBtn.onclick=()=>autoRotate=!autoRotate;

 window.addEventListener("resize",resize);
}

function createShape(){
 if(model) scene.remove(model);

 let g;
 switch(shape.value){
  case "sphere": g=new THREE.SphereGeometry(0.12,32,32); break;
  case "cylinder": g=new THREE.CylinderGeometry(0.08,0.08,0.18,32); break;
  case "cone": g=new THREE.ConeGeometry(0.1,0.18,32); break;
  case "triPrism": g=new THREE.CylinderGeometry(0.08,0.08,0.18,3); break;
  case "pyramid": g=new THREE.ConeGeometry(0.1,0.18,4); break;
  default: g=new THREE.BoxGeometry(0.15,0.15,0.15);
 }

 g.clearGroups();
 const f=g.index.count/3;
 for(let i=0;i<f;i++) g.addGroup(i*3,3,i);

 const mats=[];
 for(let i=0;i<f;i++)
  mats.push(new THREE.MeshStandardMaterial({
   color:new THREE.Color().setHSL(i/f,0.85,0.6)
  }));

 model=new THREE.Mesh(g,mats);
 model.position.set(0,0,-0.6); // üëà LU√îN HI·ªÜN TR∆Ø·ªöC CAMERA
 scene.add(model);

 edges=new THREE.LineSegments(
  new THREE.EdgesGeometry(g),
  new THREE.LineBasicMaterial({color:0x000000})
 );
 model.add(edges);

 vertices=new THREE.Group();
 if(["cube","triPrism","pyramid"].includes(shape.value)){
  const p=g.attributes.position;
  const used={};
  for(let i=0;i<p.count;i++){
   const k=`${p.getX(i).toFixed(2)}_${p.getY(i).toFixed(2)}_${p.getZ(i).toFixed(2)}`;
   if(used[k]) continue; used[k]=true;
   const s=new THREE.Sprite(new THREE.SpriteMaterial({color:0xff0000}));
   s.position.set(p.getX(i),p.getY(i),p.getZ(i));
   s.scale.set(0.03,0.03,0.03);
   vertices.add(s);
  }
 }
 model.add(vertices);
}

function animate(){
 renderer.setAnimationLoop(()=>{
  if(model && autoRotate) model.rotation.y+=0.01;
  renderer.render(scene,camera);
 });
}

function resize(){
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>
