<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>AR Hình học không gian 3D</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body { margin: 0; overflow: hidden; font-family: Arial; }
#ui {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(255,255,255,0.9);
  padding: 10px;
  border-radius: 10px;
  z-index: 10;
}
button, select {
  width: 100%;
  margin-top: 5px;
  padding: 6px;
}
</style>
</head>

<body>
<div id="ui">
  <select id="shape">
    <option value="cube">Lập phương</option>
    <option value="sphere">Hình cầu</option>
    <option value="cylinder">Hình trụ</option>
    <option value="cone">Hình nón</option>
    <option value="triPrism">Lăng trụ tam giác</option>
    <option value="pyramid">Chóp tứ giác</option>
  </select>
  <button id="edges">Ẩn/Hiện cạnh</button>
  <button id="vertices">Ẩn/Hiện đỉnh</button>
  <button id="rotate">Bật/Tắt xoay</button>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/webxr/ARButton.js";

let scene, camera, renderer;
let reticle, hitTestSource = null;
let current = null, autoRotate = false;
let edgesObj = null, vertexGroup = null;

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 20);

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.xr.enabled = true;
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures:["hit-test"] }));

  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1.2));

  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.06, 0.08, 32),
    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
  );
  reticle.rotation.x = -Math.PI/2;
  reticle.visible = false;
  scene.add(reticle);

  renderer.xr.addEventListener("sessionstart", async () => {
    const session = renderer.xr.getSession();
    const viewerSpace = await session.requestReferenceSpace("viewer");
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
  });

  renderer.domElement.addEventListener("click", () => {
    if (!reticle.visible) return;
    if (!current) createShape();
    current.position.copy(reticle.position);
  });

  setupUI();
  window.addEventListener("resize", onResize);
}

function createShape() {
  if (current) scene.remove(current);

  const type = shape.value;
  let geom;

  if (type==="cube") geom = new THREE.BoxGeometry(0.15,0.15,0.15);
  if (type==="sphere") geom = new THREE.SphereGeometry(0.1,32,32);
  if (type==="cylinder") geom = new THREE.CylinderGeometry(0.08,0.08,0.18,32);
  if (type==="cone") geom = new THREE.ConeGeometry(0.09,0.18,32);
  if (type==="triPrism") geom = new THREE.CylinderGeometry(0.08,0.08,0.18,3);
  if (type==="pyramid") geom = new THREE.ConeGeometry(0.1,0.18,4);

  geom.clearGroups();
  const faces = geom.index.count / 3;
  for(let i=0;i<faces;i++) geom.addGroup(i*3,3,i);

  const mats = [];
  for(let i=0;i<faces;i++){
    mats.push(new THREE.MeshStandardMaterial({
      color: new THREE.Color().setHSL(i/faces,0.8,0.6)
    }));
  }

  current = new THREE.Mesh(geom, mats);
  scene.add(current);

  edgesObj = new THREE.LineSegments(
    new THREE.EdgesGeometry(geom),
    new THREE.LineBasicMaterial({ color:0x000000 })
  );
  current.add(edgesObj);

  vertexGroup = new THREE.Group();
  if (["cube","triPrism","pyramid"].includes(type)) {
    const pos = geom.attributes.position;
    const used = {};
    let idx = 0;
    for(let i=0;i<pos.count;i++){
      const key = `${pos.getX(i).toFixed(2)}_${pos.getY(i).toFixed(2)}_${pos.getZ(i).toFixed(2)}`;
      if(used[key]) continue;
      used[key]=true;
      const s = new THREE.Sprite(new THREE.SpriteMaterial({ color:0xff0000 }));
      s.position.set(pos.getX(i),pos.getY(i),pos.getZ(i));
      s.scale.set(0.02,0.02,0.02);
      vertexGroup.add(s);
      idx++;
    }
  }
  current.add(vertexGroup);
}

function setupUI(){
  edges.onclick = ()=> edgesObj.visible = !edgesObj.visible;
  vertices.onclick = ()=> vertexGroup.visible = !vertexGroup.visible;
  rotate.onclick = ()=> autoRotate = !autoRotate;
}

function animate(){
  renderer.setAnimationLoop((t,frame)=>{
    if(frame && hitTestSource){
      const ref = renderer.xr.getReferenceSpace();
      const hit = frame.getHitTestResults(hitTestSource);
      if(hit.length){
        reticle.visible = true;
        reticle.matrix.fromArray(hit[0].getPose(ref).transform.matrix);
        reticle.matrix.decompose(reticle.position,reticle.quaternion,reticle.scale);
      }
    }
    if(current && autoRotate) current.rotation.y += 0.01;
    renderer.render(scene,camera);
  });
}

function onResize(){
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>
